<?php
// $Id$

/**
 * @file
 *
 * Flag note module uses a new flag_link_type 'Flag note form' to allow users
 * to attached a note to flags defined to use this link_type.
 */

/**
 * Implementation of hook_perm().
 *
 * We assume that 'create flag note' is handled by the 'create flag' permission
 * 'view any note' goes through views permissions.
 */
function flag_note_perm() {
  return array(
    'delete own flag note',
    'delete any flag note',
    'edit own flag note',
    'edit any flag note',
  );
}

/**
 * Implementation of hook_preprocess_flag().
 */
function flag_note_preprocess_flag(&$vars) {
  if ($vars['flag']->link_type == 'flag_note_form') {
    $vars['flag_classes'] .= ' flag-note';
    if ($vars['action'] == 'flag' && module_exists('modalframe')) {
      drupal_add_js(drupal_get_path('module', 'flag_note') .'/flagnote_modalframe.js');
      modalframe_parent_js();
      $vars['flag_classes'] .= ' modalframe-flagnote';
    }
    elseif ($vars['action'] == 'flag' && module_exists('popups')) {
      popups_add_popups();
      $vars['flag_classes'] .= ' popups-form';
    }
  }
}

/**
 * Implementation of hook_views_api().
 */
function flag_note_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'flag_note') .'/includes',
  );
}

/**
 * Implementation of hook_menu().
 */
function flag_note_menu() {
  $items = array();
  $items['flagnote/action'] = array(
    'title' => 'Flag Note',
    'page callback' => 'flag_note_page',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['flagnote/%/delete'] = array(
    'title' => 'Flag Note delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('flag_note_delete_confirm', 1),
    'access callback' => 'flag_note_has_access',
    'access arguments' => array(2, 1),
    'type' => MENU_CALLBACK,
  );
  $items['flagnote/%/edit'] = array(
    'title' => 'Flag Note edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('flag_note_edit_form', 1),
    'access callback' => 'flag_note_has_access',
    'access arguments' => array(2, 1),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Global flags (uid = 0) can only be edited/deleted by users that have the
 * 'edit/delete any flag note' right.
 *
 * @param type 'edit' or 'delete'
 */
function flag_note_has_access($type, $fnid, $uid = NULL) {
  if (empty($fnid)) {
    return FALSE;
  }
  if (user_access($type .' any flag note')) {
    return TRUE;
  }
  if (!user_access($type .' own flag note')) {
    return FALSE;
  }
  if (empty($uid)) {
    $note = flag_note_get_notes(array('fnid' => $fnid));
    if (empty($note)) {
      return FALSE;
    }
    $uid = $note[0]['uid'];
  }
  return ($uid === $GLOBALS['user']->uid);
}

/**
 * Form for confirming deletion of a note.
 */
function flag_note_delete_confirm(&$form_state, $fnid) {
  $form['fnid'] = array(
    '#type' => 'value',
    '#value' => $fnid,
  );
  return confirm_form($form,
    t('Are you sure you want to delete this note ?'),
    isset($_GET['destination']) ? $_GET['destination'] : $_REQUEST['q']
  );
}

/**
 * Submit handler for confirming deletion of a note.
 */
function flag_note_delete_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    $flag_note = current(flag_note_get_notes(array('fnid' => $form_state['values']['fnid'])));
    $flag = flag_get_flag(NULL, $flag_note['fid']);
    if (variable_get('flag_note_delete_unflags_'. $flag->name, FALSE)) {
      $flag->flag('unflag', $flag_note['content_id'], user_load($flag_note['uid']));
    }
    if (flag_note_remove_notes(array('fnid' => $form_state['values']['fnid']))) {
      drupal_set_message(t('Your note was successfully deleted.'));
    }
    else {
      drupal_set_message(t('Your note cannot be deleted.'), 'error');
    }
  }
}

/**
 * Form for editing a note.
 */
function flag_note_edit_form(&$form_state, $fnid) {
  $flag_note = current(flag_note_get_notes(array('fnid' => $fnid)));
  if (empty($flag_note)) {
    return FALSE;
  }

  $flag = flag_get_flag(NULL, $flag_note['fid']);
  if (empty($flag)) {
    return FALSE;
  }

  $form = array();

  $form['fnid'] = array(
    '#type' => 'value',
    '#value' => $flag_note['fnid']
  );

  $form['note'] = array(
    '#type' => 'textarea',
    '#title' => variable_get('flag_note_label_'. $flag->name, t('Flag note')),
    '#cols' => 60,
    '#rows' => 5,
    '#description' => variable_get('flag_note_help_'. $flag->name, t('A descriptive reason.')),
    '#weight' => -1,
    '#required' => TRUE,
    '#default_value' => $flag_note['note'],
  );

  $maxlen = variable_get('flag_note_maxlength_'. $flag->name, 0);
  if ($maxlen > 0) {
    $form['note']['#maxlength'] = $maxlen;
  }

  drupal_set_title(variable_get('flag_note_title_'. $flag->name, t('Flag note')));

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => $flag->get_label('flag_short', $flag_note['content_id']),
  );

  $form['cancel'] = array(
      '#value' => l(t('Cancel'), $_GET['destination'])
  );

  return $form;
}

/**
 * Submit handler for editing a note.
 */
function flag_note_edit_form_submit(&$form, $form_state) {
  $flag_note = current(flag_note_get_notes(array('fnid' => $form_state['values']['fnid'])));
  $flag_note['note'] = $form_state['values']['note'];
  if (flag_note_update_note($flag_note)) {
    drupal_set_message(t('Changes succesfully saved'));
  }
}

/**
 * Add options to the flag form:
 *  - disable note history
 *  - add a max length to a note
 *  - change the flag note labels and help text
 */
function flag_note_form_flag_form_alter(&$form, $form_state) {
  drupal_add_js(drupal_get_path('module', 'flag_note') .'/flag_note.js');

  $form['flag_note'] = array(
    '#type' => 'fieldset',
    '#name' => t('Flag note options'),
    '#tree' => TRUE,
    '#weight' => 100,
    '#attributes' => array('id' => 'flag-note-options'),
  );

  $form['flag_note']['disable_history'] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('flag_note_history_disabled_'. $form['#flag']->name, 0),
    '#title' => t('Disable flag history'),
    '#description' => t('If checked, user\'s former notes are deleted when unflagging so '.
      'only the last one will be stored.<br />Beware: if checked and in case of a global flag, '.
      'notes added by <em>other</em> users get deleted when unflagging.'),
  );

  $form['flag_note']['delete_unflags'] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('flag_note_delete_unflags_'. $form['#flag']->name, 0),
    '#title' => t('Unflag item when deleting note'),
    '#description' => t('If checked, items are unflagged when deleting flag note.'.
      '<br />Beware: if checked and in case of a global flag, '.
      'items flagged by <em>other</em> users get unflagged as well.'),
  );

  $form['flag_note']['title'] = array(
    '#type' => 'textfield',
    '#default_value' => variable_get('flag_note_title_'. $form['#flag']->name, t('Flag note')),
    '#title' => t('Flag note form title'),
  );

  $form['flag_note']['label'] = array(
    '#type' => 'textfield',
    '#default_value' => variable_get('flag_note_label_'. $form['#flag']->name, t('Flag note')),
    '#title' => t('Flag note textarea label'),
  );

  $form['flag_note']['help'] = array(
    '#type' => 'textfield',
    '#default_value' => variable_get('flag_note_help_'. $form['#flag']->name, t('A descriptive reason.')),
    '#title' => t('Flag note help text (behind textarea)'),
  );

  $form['flag_note']['flag_note_vocab'] = array(
    '#type' => 'select',
    '#title' => t('Taxonomy vocabulary to use for predefined notes'),
    '#default_value' => variable_get('flag_note_vocab_'. $form['#flag']->name, FALSE),
    '#options' => _flag_note_get_vocabs(),
    '#description' =>
      t('Flaggers will be able to select one of the predefined notes (terms) along with the textarea.')
  );

  $form['flag_note']['flag_note_vocab_label'] = array(
    '#type' => 'textfield',
    '#default_value' => variable_get('flag_note_vocab_label_'. $form['#flag']->name, t('Reason')),
    '#title' => t('Label for predefined notes'),
  );

  $form['flag_note']['flag_note_vocab_help'] = array(
    '#type' => 'textfield',
    '#title' => t('Help text for predefined notes'),
    '#default_value' => variable_get('flag_note_vocab_help_'. $form['#flag']->name, t('Please select a reason')),
  );

  $form['flag_note']['hide_text'] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('flag_note_hide_text_'. $form['#flag']->name, NULL),
    '#title' => t('use only predefined terms and hide text input'),
  );

  $form['flag_note']['default_text'] = array(
    '#type' => 'textarea',
    '#default_value' => variable_get('flag_note_default_text_'. $form['#flag']->name, NULL),
    '#title' => t('Note default text'),
  );

  if (module_exists('token')) {
    $form['flag_note']['token_help'] = array(
      '#title' => t('Replacement patterns'),
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $form['flag_note']['token_help']['help'] = array(
      '#value' => theme('token_help', $form['#flag']->content_type),
    );
  }

  $form['flag_note']['maxlength'] = array(
    '#type' => 'textfield',
    '#default_value' => variable_get('flag_note_maxlength_'. $form['#flag']->name, 0),
    '#title' => t('Flag note max length'),
    '#description' => t('0 for unlimited'),
    '#length' => 8,
  );

  $form['#validate'][] = 'flag_note_flag_form_validate';
  $form['#submit'][]   = 'flag_note_flag_form_submit';
}

function flag_note_flag_form_validate($form, &$form_state) {
  if (empty($form_state['values']['flag_note']['flag_note_vocab'])
      and !empty($form_state['values']['flag_note']['hide_text']))
  {
    form_set_error('hide_text', t('To hide the flag note textarea you must select a vocabulary for predefined text'));
  }
}

/**
 * Additional submit handler added to the flag form.
 */
function flag_note_flag_form_submit($form, &$form_state) {
  variable_set('flag_note_title_'. $form['#flag']->name, $form_state['values']['flag_note']['title']);
  variable_set('flag_note_label_'. $form['#flag']->name, $form_state['values']['flag_note']['label']);
  variable_set('flag_note_help_'. $form['#flag']->name, $form_state['values']['flag_note']['help']);
  variable_set('flag_note_history_disabled_'. $form['#flag']->name, $form_state['values']['flag_note']['disable_history']);
  variable_set('flag_note_delete_unflags_'. $form['#flag']->name, $form_state['values']['flag_note']['delete_unflags']);
  variable_set('flag_note_default_text_'. $form['#flag']->name, $form_state['values']['flag_note']['default_text']);
  variable_set('flag_note_maxlength_'. $form['#flag']->name, $form_state['values']['flag_note']['maxlength']);
  if ($form_state['values']['flag_note']['flag_note_vocab']) {
    variable_set('flag_note_vocab_'. $form['#flag']->name, $form_state['values']['flag_note']['flag_note_vocab']);
    variable_set('flag_note_vocab_label_'. $form['#flag']->name, $form_state['values']['flag_note']['flag_note_vocab_label']);
    variable_set('flag_note_vocab_help_'. $form['#flag']->name, $form_state['values']['flag_note']['flag_note_vocab_help']);
  }
  else {
    variable_del('flag_note_vocab_'. $form['#flag']->name);
  }
  variable_set('flag_note_hide_text_'. $form['#flag']->name, $form_state['values']['flag_note']['hide_text']);
}

/**
 * Helper function to determine if a flag's history has been disabled.
 */
function _flag_note_history_disabled($flag_name) {
  return variable_get('flag_note_history_disabled_'. $flag_name, 0);
}

/**
 * Implementation of hook_nodeapi().
 *
 * Deletes notes once a node is deleted.
 */
function flag_note_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch ($op) {
    case 'delete':
      flag_note_remove_notes(array('content_type' => 'node', 'content_id' => $node->nid));
    break;
  }
}

/**
 * Implementation of hook_user().
 *
 * Deletes notes once an user is deleted.
 */
function flag_note_user($op, &$edit, &$account, $category = NULL) {
  switch ($op) {
    case 'delete':
      flag_note_remove_notes(array('content_type' => 'user', 'content_id' => $account->uid));
    break;
  }
}

/**
 * Implementation of hook_comment().
 *
 * Deletes notes once a comment is deleted.
 */
function flag_note_comment(&$a1, $op) {
  switch ($op) {
    case 'delete':
      flag_note_remove_notes(array('content_type' => 'comment', 'content_id' => $a1->cid));
    break;
  }
}

/**
 * Implementation of hook_form_alter().
 *
 * Deletes notes once a flag is deleted.
 */
function flag_note_form_flag_delete_confirm_alter(&$form, $form_state) {
  $form['#submit'][] = 'flag_note_flag_delete_confirm_submit';
}

/**
 * Additional submit handler added to the flag delete confirmation form.
 */
function flag_note_flag_delete_confirm_submit($form, &$form_state) {
  flag_note_remove_notes(array('fid' => $form_state['values']['fid']));
}

/**
 * Called from the flag's link which is set up in hook_flag_link.
 */
function flag_note_page($action, $flag_name, $content_id) {
  $flag = flag_get_flag($flag_name);
  switch ($action) {
    case 'flag';
      return drupal_get_form('flag_note_form', $action, $flag_name, $content_id);
      break;
    case 'unflag':
      // Delete old note if history is disabled.
      if (_flag_note_history_disabled($flag_name)) {
        if ($flag->global) {
          flag_note_remove_notes(array('content_type' => $flag->content_type, 'content_id' => $content_id));
        }
        else {
          flag_note_remove_notes(array('content_type' => $flag->content_type, 'content_id' => $content_id, 'uid' => $GLOBALS['user']->uid));
        }
      }
      flag_page($action, $flag, $content_id);
      break;
    default:
      return flag_page($action, $flag, $content_id);
      break;
  }
}

/**
 * Form for entering a new note.
 */
function flag_note_form(&$form_state, $action, $flag_name, $content_id) {
  if (module_exists('modalframe')) {
    modalframe_child_js();
  }
  $form = array();

  drupal_set_title(variable_get('flag_note_title_'. $flag_name, ''));

  $form['flag_note'] = array(
    '#type' => 'fieldset',
    '#tree' => FALSE,
    '#title' => variable_get('flag_note_title_'. $flag_name, ''),
  );

  $form['flag_note']['action'] = array(
    '#type' => 'value',
    '#value' => 'flag',
  );
  $form['flag_note']['flag_name'] = array(
    '#type' => 'value',
    '#value' => $flag_name,
  );
  $form['flag_note']['content_id'] = array(
    '#type' => 'value',
    '#value' => $content_id,
  );

  $vid = variable_get('flag_note_vocab_'. $flag_name, FALSE);
  if ($vid) {
    $form['flag_note']['tid'] = array(
      '#title' => variable_get('flag_note_vocab_label_'. $flag_name, ''),
      '#description' => variable_get('flag_note_vocab_help_'. $flag_name, ''),
      '#required' => FALSE,
      '#weight' => -2,
    ) + taxonomy_form($vid);
  }

  $default_value = variable_get('flag_note_default_text_'. $flag_name, '');

  if (module_exists('token')) {
    $flag = flag_get_flag($flag_name);
    $default_value = $flag->replace_tokens($default_value,
      array_flip($flag->get_labels_token_types()), $content_id);
  }

  if (!variable_get('flag_note_hide_text_'. $flag_name, FALSE)) {
    $form['flag_note']['note'] = array(
      '#type' => 'textarea',
      '#title' => variable_get('flag_note_label_'. $flag_name, ''),
      '#cols' => 60,
      '#rows' => 5,
      '#description' => variable_get('flag_note_help_'. $flag_name, ''),
      '#weight' => -1,
      '#required' => TRUE,
      '#default_value' => $default_value,
    );

    $maxlen = variable_get('flag_note_maxlength_'. $flag_name, 0);
    if ($maxlen > 0) {
      $form['flag_note']['note']['#maxlength'] = $maxlen;
    }
  }

  $flag = flag_get_flag($flag_name);
  $form['flag_note']['submit'] = array(
    '#type' => 'submit',
    '#value' => $flag->get_label('flag_short', $content_id),
  );
  return $form;
}

/**
 * Submit handler for adding a new note.
 */
function flag_note_form_submit(&$form, &$form_state) {
  $flag = flag_get_flag($form_state['values']['flag_name']);

  // Add our info to the flag object to use in tokens when flagging.
  if (module_exists('token')) {
    $flag->flag_note['text'] = $form_state['values']['note'];
    if ($form_state['values']['tid']) {
      $term = taxonomy_get_term($form_state['values']['tid']);
      if ($term) {
        $flag->flag_note['term'] = $term->name; 
      }
    }
  }

  $result = $flag->flag($form_state['values']['action'], $form_state['values']['content_id']);
  if (empty($result)) {
    drupal_set_message(t('You are not allowed to flag, or unflag, this content.'));
  }
  else {
    $userflag = flag_get_user_flags($flag->content_type, $form_state['values']['content_id'], $GLOBALS['user']->uid);
    $record = $userflag[$flag->name];

    // Now uid = 0 if is a global flag. Anyway we want to store the note author
    // so we change it.
    $record->uid  = $GLOBALS['user']->uid;
    $record->note = $form_state['values']['note'];
    $record->tid = ($form_state['values']['tid'] > 0 ? $form_state['values']['tid'] : NULL);
    flag_note_insert_note($record);
    drupal_set_message($flag->get_label($form_state['values']['action'] .'_message', $form_state['values']['content_id']));
  }

  // Modalframe support.
  if (module_exists('modalframe')) {
    modalframe_close_dialog(array(
      'message' => t('Changes were succesfully saved'),
    ));
  }
}

/**
 * Implementation of hook_flag_link_types().
 *
 * Defines a link type that the admin can select when editting a flag.
 */
function flag_note_flag_link_types() {
  return array('flag_note_form' => array(
    'title' => t('Flag note form'),
    'description' => t('The user will be able to relate a note to the flagging operation.')
  ));
}

/**
 * Implementation of hook_flag_link().
 *
 * Build the callback link for flags.
 */
function flag_note_flag_link($flag, $action, $content_id) {
  $token = flag_get_token($content_id);
  return array(
    'href' => "flagnote/action/$action/$flag->name/$content_id",
    'query' => drupal_get_destination() .'&token='. $token,
  );
}

/**
 * @defgroup Database interaction.
 * @{
 */

function flag_note_get_schema() {
  static $schema = NULL;
  if (empty($schema)) {
    $schema = drupal_get_schema('flag_note');
  }
  return $schema;
}

function flag_note_insert_note($record) {
  $record = (array) $record;
  $record['note'] = filter_xss($record['note']);
  return drupal_write_record('flag_note', $record);
}

function flag_note_update_note($options) {
  return drupal_write_record('flag_note', $options, 'fnid');
}

function flag_note_remove_notes($options) {
  $schema = flag_note_get_schema();
  foreach ($options as $field => $value) {
    $where[] = $field .' = '. db_type_placeholder($schema['fields'][$field]['type']);
  }
  return db_query('DELETE FROM {flag_note} WHERE '. implode(' AND ', $where), $options);
}

function flag_note_get_notes($options) {
  $notes = array();
  $schema = flag_note_get_schema();
  foreach ($options as $field => $value) {
    $where[] = $field .' = '. db_type_placeholder($schema['fields'][$field]['type']);
  }
  $result = db_query('SELECT * FROM {flag_note} WHERE '. implode(' AND ', $where), $options);
  while ($note = db_fetch_array($result)) {
    $notes[] = $note;
  }
  return $notes;
}

/**
 * @}
 */

/**
 * Implementation of hook_token_list().
 */
function flag_note_token_list($type = 'all') {
  $tokens = array();
  if ($type == 'flag') {
    $tokens['flag note']['flag-note-text'] = t('The note associated with the flagging action.');
    $tokens['flag note']['flag-note-term'] = t('The term associated with the flagging action.');
  }
  return $tokens;
}

/**
 * Implementation of hook_token_values().
 */
function flag_note_token_values($type, $object = NULL, $options = array()) {
  $values = array();
  if ($type == 'flag' and !empty($object->flag_note)) {
    $values['flag-note']      = // Keep this for backward compatibility
    $values['flag-note-text'] = check_plain($object->flag_note['text']);
    $values['flag-note-term'] = check_plain($object->flag_note['term']);
  }
  return $values;
}

/**
 * Get list of vocabs.
 */
function _flag_note_get_vocabs() {
  $vocabs = taxonomy_get_vocabularies();
  $options[0] = t("- none -");
  foreach ($vocabs as $vid => $vocab) {
    $options[$vid] = t($vocab->name);
  }
  return $options;
}
